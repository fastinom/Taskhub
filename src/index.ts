import {
  query,
  update,
  Record,
  StableBTreeMap,
  Vec,
  nat64,
  ic,
  Opt,
  None,
  text,
  Canister,
  Principal,
  bool,
  Ok,
  Err,
  Variant,
  Result,
  Some,
} from "azle";
import { v4 as uuidv4 } from "uuid";

const Task = Record({
  id: text,
  title: text,
  taskOwner: Principal,
  description: text,
  dueDate: Opt(nat64),
  completed: bool,
  createdAt: nat64,
  updatedAt: Opt(nat64),
});

type Task = typeof Task;

const TaskPayload = Record({
  title: text,
  description: text,
  dueDate: Opt(nat64),
});

type TaskPayload = typeof TaskPayload;

let taskStorage = StableBTreeMap<text, Task>(text, Task, 0);

// Error variable 
const TaskError = Variant({
  InvalidPayload: text,
  NotTaskOwner: Principal
});

// Helper function that trims the input string and then checks the length
// The string is empty if true is returned, otherwise, string is a valid value
function isInvalidString(str: string): boolean {
  return str.trim().length == 0
}

// Helper function to ensure the input id meets the format used for ids generated by uuid
function isValidUuid(id: string): boolean {
  const regexExp = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi;
  return regexExp.test(id);
}


export default Canister({
  // allows users to fetch all tasks stored on the canister
  getTasks: query([], Vec(Task), () => {
    return taskStorage.values();
  }),

  // allows users to get a task with id from the canister
  getTask: query([text], Result(Task, TaskError), (id) => {
    // if id is not in the valid uuid format, return an error
    if (!isValidUuid(id)){
      return Err({InvalidPayload: `Invalid id. id='${id}' needs to be in the valid uuid format.`})
    }
    // result of fetching task from storage
    const taskOpt = taskStorage.get(id);
    // return an error if task with id doesn't exist
    if ('None' in taskOpt) {
      return Err({InvalidPayload: `Task with id=${id} not found.`})
    }
    // return task
    return Ok(taskOpt.Some)
    
  }),

  // allows users to add a task to the canister
  addTask: update([TaskPayload],  Result(Task, TaskError), (payload) => {
    // ensures the input string values do not contain empty or invalid values such as " "
    if (isInvalidString(payload.title) || isInvalidString(payload.description)){
      return Err({
        InvalidPayload: `Payload input data cannot contain empty values for title='${payload.title}' and description='${payload.description}'`
      })
    }
    const dueDate = payload.dueDate.Some;
    // if a value for dueDate was specified and dueDate is less or equal to the current timestamp, return an error
    if (dueDate && dueDate <= ic.time()){
      return Err({
        InvalidPayload: `dueDate=${dueDate} must be greater than the current timestamp=${ic.time()}`
      })
    }
    const task: Task = {
      id: uuidv4(),
      taskOwner: ic.caller(),
      createdAt: ic.time(),
      updatedAt: None,
      completed: false,
      description: payload.description,
      title: payload.title,
      dueDate: dueDate? Some(dueDate): None
    };
    // save task to canister
    taskStorage.insert(task.id, task);
    return Ok(task);
  }),
  
  // allows users to update a task as completed
  completeTask: update([text], Result(Task, TaskError), (id) => {
    // return an error if id is not in the valid format
    if (!isValidUuid(id)){
      return Err({InvalidPayload: `Invalid id. id='${id}' needs to be in the valid uuid format.`})
    }
    const taskOpt = taskStorage.get(id);
    // if task doesn't exist, return an error
    if ('None' in taskOpt) {
      return Err({InvalidPayload: `Task with id=${id} not found.`})
    }
    let task :Task = taskOpt.Some;
    // if caller is not the task owner, return an error
    if (task.taskOwner.toString() != ic.caller().toString()){
      return Err({NotTaskOwner: ic.caller()})
    }
    let updatedTask: Task = {
      ...task,
      completed: true
    }
    taskStorage.insert(id, updatedTask);
    return Ok(updatedTask);
  }),

  // allows users to delete a task from the canister
  deleteTask: update([text], Result(Task, TaskError), (id) => {
    // return an error if id is not in the valid format
    if (!isValidUuid(id)){
      return Err({InvalidPayload: `Invalid id. id='${id}' needs to be in the valid uuid format.`})
    }
    const taskOpt = taskStorage.get(id);
    // if task doesn't exist, return an error
    if ('None' in taskOpt) {
      return Err({InvalidPayload: `Task with id=${id} not found.`})
    }
    let task :Task = taskOpt.Some;
    // if caller is not the task owner, return an error
    if (task.taskOwner.toString() != ic.caller().toString()){
      return Err({NotTaskOwner: ic.caller()})
    }
    taskStorage.remove(id);
    return Ok(task);
  }),
});

// a workaround to make uuid package work with Azle
globalThis.crypto = {
  // @ts-ignore
  getRandomValues: () => {
    let array = new Uint8Array(32);

    for (let i = 0; i < array.length; i++) {
      array[i] = Math.floor(Math.random() * 256);
    }

    return array;
  },
};
